function GenerateScene()
FibreWrite2DX();

% positionsFile = './data/Positions_Large.txt';
% eigenFile = './data/EigenValue_Large.txt';
% rotationFile = './data/Rotation_Large.txt';
% eigenVector = './data/EigenVector_Large.txt';

positionsFile = './data/Positions_Large1A.txt';
eigenFile = './data/Eigenvalues_Large1A.txt';
rotationFile = './data/Rotations_Large1A.txt';
eigenVector = './data/Eigenvectors_Large1A.txt';


Positions = readDataFile(positionsFile);
EigenData = readDataFile(eigenFile);
RotationData = readRotationFile(rotationFile);
EigenVector = readRotationFile(eigenVector);

numberOfGlyphs = size(Positions,1);

% define the ellipsoid density
nx = 20;
ny = 20;

xMin = -1*pi*0.5;
xMax = pi*0.5;
yMin = -1*pi;
yMax =pi;

xstep = (xMax-xMin)/(nx-1);
ystep = (yMax-yMin)/(ny-1);


%RGB Colour from either EigenValues or EigenVectors
RGB = zeros(numberOfGlyphs*nx*ny,3);
for i = 1:numberOfGlyphs
    for j = 1:nx*ny
        RGB(j+(i-1)*nx*ny,:) = abs(EigenVector(i,1:3));
        %RGB(j+(i-1)*nx*ny,:) = abs(100*EigenData(i,1:3));
    end
end

GridPositions = zeros(nx*ny, 2);
counter = 1;
for j = 1:ny
	for i = 1:nx
		GridPositions(counter, 1) = xMin + (i-1)*xstep;
		GridPositions(counter, 2) = yMin + (j-1)*ystep;
		counter = counter +1;
	end
end

%TRI = delaunay(GridPositions(:,1), GridPositions(:,2));
QUADS = zeros((nx-1)*(ny-1), 4);
numberOfQuads = (nx-1)*(ny-1);

counter = 1;
mx = nx;
for j = 0:(ny-2)
	for i = 0:(nx-2)
		QUADS(counter, 1) = i+j*mx;
		QUADS(counter, 2) = i+j*mx + 1;
		
		QUADS(counter, 3) = i+(j+1)*mx;
		QUADS(counter, 4) = i+(j+1)*mx + 1;
		counter = counter +1;
	end
end


%PointPlot3D(GridPositions(:,1), GridPositions(:,2), zeros(nx*ny,1));
%quadmesh(QUADS, GridPositions(:,1), GridPositions(:,2), zeros(nx*ny,1));
%numberOfGlyphs = 5;
AllPoints = zeros(nx*ny*numberOfGlyphs, 3);
%AllPointData = zeros(nx*ny*numberOfGlyphs);
TempPoints = zeros(nx*ny, 3);
RotationMatrix = zeros(3,3);
for i = 1:numberOfGlyphs
	% Create the rotation Matrix
	RotationMatrix = [RotationData(i,1:3); RotationData(i,4:6); RotationData(i,7:9)];

	% For this data point, generate a glyph at this position
	TempPoints = GenerateEllipsoid(GridPositions, Positions(i, :), EigenData(i,:), 1, RotationMatrix);
	
	% Now to stick the new points into our big structure
	AllPoints((i-1)*nx*ny +1: i*nx*ny, :) = TempPoints(:,:);
	% Make each ellipsoid a single colour
	AllPointData((i-1)*nx*ny +1: i*nx*ny, 1) = i;
	% Make each ellipsoid multi colour
	%AllPointData((i-1)*nx*ny +1: i*nx*ny, 1) = (i-1)*(1:nx*ny);
end
%disp(AllPoints);

%PointPlot3D(AllPoints(:,1), AllPoints(:,2), AllPoints(:,3));

Write2DX(AllPoints, QUADS, numberOfGlyphs, AllPointData,RGB);
%WriteToVTKFile(AllPoints, QUADS);




%
%
%
function [newPoints] = GenerateEllipsoid(Grid, Origin, eigenData, Scale, Rotation)

numberOfPoints = size(Grid, 1);
newPoints = zeros(numberOfPoints, 3);
for i = 1:numberOfPoints
	newPoints(i, 1) = 1*cos(Grid(i,1))*cos(Grid(i,2));%*Scale + Origin(1,1);
	newPoints(i, 2) = 1*cos(Grid(i,1))*sin(Grid(i,2));%*Scale + Origin(1,2);
	newPoints(i, 3) = 1*sin(Grid(i,1));%*Scale + Origin(1,3);
	
	newPoints(i,:) = Rotation*newPoints(i,:)';
	
	newPoints(i, 1) = eigenData(1,1)*newPoints(i,1)*Scale + Origin(1,1);
	newPoints(i, 2) = eigenData(1,2)*newPoints(i,2)*Scale + Origin(1,2);
	newPoints(i, 3) = eigenData(1,3)*newPoints(i,3)*Scale + Origin(1,3);
end


return


function PointPlot3D(X1, Y1, Z1)
%CREATEFIGURE(X1,Y1,Z1)
%  X1:  vector of x data
%  Y1:  vector of y data
%  Z1:  vector of z data

%  Auto-generated by MATLAB on 14-Aug-2009 10:16:35

% Create figure
figure1 = figure('XVisual',...
    '0x23 (TrueColor, depth 32, RGB mask 0xff0000 0xff00 0x00ff)');

% Create axes
axes1 = axes('Parent',figure1);
view(axes1,[-19.5 60]);
hold(axes1,'all');

% Create plot3
plot3(X1,Y1,Z1,'Marker','.','LineStyle','none');


